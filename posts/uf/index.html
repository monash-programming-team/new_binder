<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Union Find / DSU" /><meta name="author" content="Jackson Goerner" /><meta property="og:locale" content="en_US" /><meta name="description" content="Where is this useful?" /><meta property="og:description" content="Where is this useful?" /><link rel="canonical" href="https://blog.monashicpc.com/new_binder//new_binder/posts/uf/" /><meta property="og:url" content="https://blog.monashicpc.com/new_binder//new_binder/posts/uf/" /><meta property="og:site_name" content="Monash Code Binder" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-15T12:00:00+11:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Union Find / DSU" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Jackson Goerner" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Jackson Goerner"},"description":"Where is this useful?","headline":"Union Find / DSU","dateModified":"2021-12-27T13:53:13+11:00","url":"https://blog.monashicpc.com/new_binder//new_binder/posts/uf/","datePublished":"2021-12-15T12:00:00+11:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.monashicpc.com/new_binder//new_binder/posts/uf/"},"@context":"https://schema.org"}</script><title>Union Find / DSU | Monash Code Binder</title><link rel="shortcut icon" href="/new_binder/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/new_binder/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="manifest" href="/new_binder/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/new_binder/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/new_binder/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/new_binder/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/new_binder/assets/js/dist/post.min.js"></script> <script src="/new_binder/assets/js/code-tabs.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@5.2/distr/fira_code.css"> <script src="/new_binder/assets/js/hints.js"></script> <script src="/new_binder/assets/js/highlight.js"></script> <script defer src="/new_binder/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/new_binder/" alt="avatar" class="mx-auto"> <img src="/new_binder/assets/img/icpc.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/new_binder/">Monash Code Binder</a></div><div class="site-subtitle font-italic">For Training / Contests</div></div><ul class="w-100"><li class="nav-item"> <a href="/new_binder/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/new_binder/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/new_binder/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/new_binder/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/new_binder/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://discord.link/MonashICPC" aria-label="discord" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-discord"></i> </a> <a href="https://www.facebook.com/groups/454114112027992" aria-label="facebook" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['jackson','monashicpc.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/new_binder/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/new_binder/"> Posts </a> </span> <span>Union Find / DSU</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Union Find / DSU</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Jackson Goerner </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 15, 2021, 12:00 PM +1100" > Dec 15, 2021 <i class="unloaded">2021-12-15T12:00:00+11:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Dec 27, 2021, 1:53 PM +1100" > Dec 27, 2021 <i class="unloaded">2021-12-27T13:53:13+11:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3380 words">18 min</span></div></div><div class="post-content"><h1 id="where-is-this-useful">Where is this useful?</h1><p>In many problems, translating into a graph structure can prove helpful, as we can describe our problem in very abstract terms.</p><p>Once you’ve translated into this graph structure, often you might want to know whether two vertices are connected via a path, and if this is not the case, what two separate components they come from. Union Find allows us to not only answer this question, but slowly add edges to the graph and still answer these queries fast.</p><p>As such, Union Find is useful in any problem where connections are incrementally being added to some structure, and along the way you need to query what vertices are connected.</p><h1 id="implementing-the-data-structure">Implementing the Data Structure</h1><h2 id="basics">Basics</h2><p>Let’s first define the interface for our Union Find. We want to provide the ability to merge two vertices, and we should be able to query two vertices, asking if they are connected.</p><p>At first, every vertex is disconnected. We can add edges later as need be.</p><div class="code-tab"> <button class="code-tablinks UF-1-link" onclick="openCodeTab(event, 'UF-1', 'UF-1-Python')">Python</button> <button class="code-tablinks UF-1-link" onclick="openCodeTab(event, 'UF-1', 'UF-1-CPP')">CPP</button></div><div id="UF-1-Python" class="code-tabcontent UF-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
    <span class="s">"""
    vertices are represented as numbers 0-&gt;n-1.
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span>
    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Whether the two vertices a and b are connected.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span></pre></table></code></div></div></div><div id="UF-1-CPP" class="code-tabcontent UF-1"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">UnionFind</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_verts</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_verts</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">connected</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Whether the two vertices a and b are connected.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div></div><p>Now, we can take our first approach at the data structure. Notice that before any merging occurs, each component is uniquely identified by a single vertex contained within. As we merge our vertices, we’ll try keep it that way.</p><p>In order to do this, we can model each component as a rooted tree. The root of this tree is the identifier, and so from any vertex in the tree, we can get to the identifier by moving up the tree.</p><p>To merge two components (trees), we simply place the second tree as a child of the first tree. The second root no longer identifies a component, and the first root is now the identifier of the combined component.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/new_binder/assets/img/posts/uf/merge_tree.png" alt="" /></p><p>So, to implement this, we’ll create a parent array, which contains the parent of each vertex. For vertices that are the root, they will be their own parents.</p><p>We will also need a method to find the identifier of any component, by moving up the tree. We will do this with <code class="language-plaintext highlighter-rouge">find</code> in the code.</p><p>And we can already get around to implementing <code class="language-plaintext highlighter-rouge">connected</code> and <code class="language-plaintext highlighter-rouge">merge</code>. For <code class="language-plaintext highlighter-rouge">connected</code>, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are in the same component if the identifier of their components are the same. For merge, we simply need to modify the <code class="language-plaintext highlighter-rouge">parent</code> attribute of one identifier, so that it points to the root of the other component:</p><div class="code-tab"> <button class="code-tablinks UF-2-link" onclick="openCodeTab(event, 'UF-2', 'UF-2-Python')">Python</button> <button class="code-tablinks UF-2-link" onclick="openCodeTab(event, 'UF-2', 'UF-2-CPP')">CPP</button></div><div id="UF-2-Python" class="code-tabcontent UF-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
    <span class="s">"""
    vertices are represented as numbers 0-&gt;n-1.
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="c1"># parent[x] = x to begin with.n
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># Find the root of this componentn
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span><span class="err"></span><span class="n">n</span>
            <span class="k">return</span> <span class="n">a</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.
</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span><span class="err"></span><span class="n">n</span>
            <span class="k">return</span> <span class="bp">False</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">True</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Whether the two vertices a and b are connected.
</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="err"></span><span class="n">n</span>
</pre></table></code></div></div></div><div id="UF-2-CPP" class="code-tabcontent UF-2"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">UnionFind</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span><span class="err"></span><span class="n">n</span>

    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_verts</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_verts</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">n_verts</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">m</span>
        <span class="n">iota</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">parent</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// Find the root of this componentn</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span><span class="err"></span><span class="n">n</span>

    <span class="kt">bool</span> <span class="n">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">connected</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Whether the two vertices a and b are connected.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div></div><h2 id="useful-data">Useful data</h2><p>A keen eye might’ve spotted that there’s possibility of some bad complexity coming out of these methods. If components are merged badly (So that we have a very unbalanced tree) we can make it so that <code class="language-plaintext highlighter-rouge">find</code> (and therefore <code class="language-plaintext highlighter-rouge">merge/connected</code>) are <code class="language-plaintext highlighter-rouge">O(n)</code> complexity. To improve this, and to make the data structure more useful as a whole, let’s take a quick detour and try to include some other data as part of our data structure:</p><ul><li><code class="language-plaintext highlighter-rouge">size</code>: This should be an array which stores the size of each component. The <code class="language-plaintext highlighter-rouge">size</code> entry for non-identifier vertices doesn’t matter and can be left with old data.<li><code class="language-plaintext highlighter-rouge">rank</code>: This should be an array which stores the maximum depth of any component tree. The <code class="language-plaintext highlighter-rouge">rank</code> entry for non-identifier vertices doesn’t matter and can be left with old data.</ul><p>It could be a good bit of practice to try this yourself; Modify the methods above to store and update the <code class="language-plaintext highlighter-rouge">size</code> and <code class="language-plaintext highlighter-rouge">rank</code> values.</p><div class="code-tab"> <button class="code-tablinks UF-3-link" onclick="openCodeTab(event, 'UF-3', 'UF-3-Python')">Python</button> <button class="code-tablinks UF-3-link" onclick="openCodeTab(event, 'UF-3', 'UF-3-CPP')">CPP</button></div><div id="UF-3-Python" class="code-tabcontent UF-3"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
    <span class="s">"""
    vertices are represented as numbers 0-&gt;n-1.
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># Number of components
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="c1"># parent[x] = x to begin with.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># size = number of vertices in componentn
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># rank = max-depth of component treen
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span><span class="err"></span><span class="n">c</span>
        <span class="c1"># Find the root of this component
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="err"></span><span class="n">c</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.
</span>        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">])</span><span class="err"></span><span class="n">n</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span><span class="err"></span><span class="n">n</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span><span class="err"></span><span class="n">c</span>
        <span class="c1"># Whether the two vertices a and b are connected.
</span>        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="err"></span><span class="n">c</span>
    <span class="k">def</span> <span class="nf">size_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># Find the size of a particular component.n
</span>        <span class="c1"># Question: Why do we need to call `find`?n
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">num_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="err"></span><span class="n">n</span>
</pre></table></code></div></div></div><div id="UF-3-CPP" class="code-tabcontent UF-3"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">UnionFind</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rank</span><span class="p">;</span>

    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_verts</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_verts</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">n_verts</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">n_verts</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rank</span><span class="p">(</span><span class="n">n_verts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">m</span>
        <span class="n">iota</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">parent</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">c</span>
        <span class="c1">// Find the root of this component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
    <span class="p">}</span><span class="err"></span><span class="n">c</span>

    <span class="kt">bool</span> <span class="n">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">size</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">b</span><span class="p">];</span><span class="err"></span><span class="n">n</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span><span class="err"></span><span class="n">n</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="n">n</span><span class="o">--</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">connected</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">c</span>
        <span class="c1">// Whether the two vertices a and b are connected.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span><span class="err"></span><span class="n">c</span>

    <span class="kt">int</span> <span class="n">size_component</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// Find the size of a particular component.n</span>
        <span class="c1">// Question: Why do we need to call `find`?n</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)];</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span><span class="err"></span><span class="n">n</span>

    <span class="kt">int</span> <span class="n">num_components</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span><span class="err"></span><span class="n">n</span>
<span class="p">};</span>
</pre></table></code></div></div></div><p>If the maximum of <code class="language-plaintext highlighter-rouge">rank[a]</code> and <code class="language-plaintext highlighter-rouge">rank[b]</code> is equal to <code class="language-plaintext highlighter-rouge">rank[b]</code>, then the total depth in the tree will be at most <code class="language-plaintext highlighter-rouge">rank[b]+1</code>, since we must include the path from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code>, before considering any children of <code class="language-plaintext highlighter-rouge">b</code>.</p><p>Armed with this information, we can make some better decisions when it comes to merging, and also start compressing the trees.</p><h2 id="depth-reduction">Depth reduction</h2><p>Since we get bad complexity when merging trees with large rank as children, let’s always pick the largest rank tree to be the identifier. Then the overall rank of the resultant tree only increases if the rank of the two original trees was the same.</p><p>Additionally, every time we call find, we are traversing up our tree. But in this traversal, it is very cheap to simply connect every vertex along the way to the root vertex, using recursion.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/new_binder/assets/img/posts/uf/find_reduce.png" alt="" /></p><div class="code-tab"> <button class="code-tablinks UF-4-link" onclick="openCodeTab(event, 'UF-4', 'UF-4-Python')">Python</button> <button class="code-tablinks UF-4-link" onclick="openCodeTab(event, 'UF-4', 'UF-4-CPP')">CPP</button></div><div id="UF-4-Python" class="code-tabcontent UF-4"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
    <span class="s">"""
    vertices are represented as numbers 0-&gt;n-1.
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span><span class="err"></span><span class="n">c</span>
        <span class="c1"># Number of components
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="c1"># parent[x] = x to begin with.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># size = number of vertices in component
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="c1"># rank = max-depth of component tree
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
<span class="err"></span><span class="n">c</span>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="c1"># Find the root of this component
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="c1"># Whenever I call find, set the parent to be right above me.n
</span>        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="n">b</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.
</span>        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">]):</span><span class="err"></span><span class="n">n</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span><span class="err"></span><span class="n">c</span>
        <span class="c1"># Whether the two vertices a and b are connected.
</span>        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="err"></span><span class="n">c</span>
    <span class="k">def</span> <span class="nf">size_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span><span class="err"></span><span class="n">c</span>
        <span class="c1"># Find the size of a particular component.
</span>        <span class="c1"># Question: Why do we need to call `find`?
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
<span class="err"></span><span class="n">c</span>
    <span class="k">def</span> <span class="nf">num_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="err"></span><span class="n">c</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">n</span>
<span class="err"></span><span class="n">c</span>
</pre></table></code></div></div></div><div id="UF-4-CPP" class="code-tabcontent UF-4"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">UnionFind</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rank</span><span class="p">;</span>

    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_verts</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_verts</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">n_verts</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">n_verts</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rank</span><span class="p">(</span><span class="n">n_verts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">iota</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">parent</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Find the root of this component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="c1">// Whenever I call find, set the parent to be right above me.n</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span><span class="err"></span><span class="n">m</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Merge the two vertices a and b. Return a boolean which is true if they weren't already merged.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
        <span class="n">size</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">rank</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="n">rank</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">n</span><span class="o">--</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">connected</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">c</span>
        <span class="c1">// Whether the two vertices a and b are connected.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span><span class="err"></span><span class="n">c</span>

    <span class="kt">int</span> <span class="n">size_component</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">c</span>
        <span class="c1">// Find the size of a particular component.</span>
        <span class="c1">// Question: Why do we need to call `find`?</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)];</span>
    <span class="p">}</span><span class="err"></span><span class="n">c</span>

    <span class="kt">int</span> <span class="n">num_components</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div></div><h2 id="complexity-analysis">Complexity Analysis</h2><p>And that is all the changes required to reduce the complexity of union find, but how much has it done?</p><p>Well, to construct a rank 2 tree we need to merge 2 rank 1 trees, to construct a rank 3 tree we need to merge 2 rank 2 trees, and so on and so forth. Therefore in a union find with n vertices, we have at most log2(n) rank on each tree in our data structure.</p><p>This means that <code class="language-plaintext highlighter-rouge">find</code> is log(n), meaning both <code class="language-plaintext highlighter-rouge">merge</code> and <code class="language-plaintext highlighter-rouge">connected</code> are also log(n). (In fact, with the path compression above, the complexity is even less (inverse ackermann), but this isn’t super important under contest conditions)</p><p>And that’s the data structure fully taken care of. Now let’s solve some problems!</p><h1 id="a-simple-application">A simple application</h1><p>Let’s try our hand at <a href="https://www.spoj.com/problems/FRNDCIRC/">Friend Circle</a>. Give it a shot yourself before reading the discussion below!</p><p>(Note: The time bounds for this problem are very small. Python will probably TLE. But give it a shot anyways!).</p><div class="unlock"><p><button class="button_unlock hint">Hint</button></p><div class="show"><p><strong>Hint</strong></p><p>While the problem description is a bit sparse, hopefully you can spot that we care about what group of friends are connected by some friendship (If A and B are friends, and B and C are friends, then all 3 form a circle of friends, no need for A and C to be friends.)</p><p>So, if we let every person be a vertex in our graph, with edges representing friendship, then Union Find is exactly the tool we need. Before we get into coding we need only ask ourselves two things:</p><ol><li>What is the maximum size of our Union Find <code class="language-plaintext highlighter-rouge">n</code>?<li>How will I turn people’s names into the digits <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>?</ol></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>To answer 1, the maximum number of people is simply 2 times the total number of connections. For 2, we can use a dictionary/map to map strings to integers. To ensure every person is unique from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n-1</code>, we can start a counter at <code class="language-plaintext highlighter-rouge">0</code>, and every time we see a new name, increment this counter. Then the old value of the counter is the id for that person:</p><div class="code-tab"> <button class="code-tablinks UF-5-link" onclick="openCodeTab(event, 'UF-5', 'UF-5-Python')">Python</button> <button class="code-tablinks UF-5-link" onclick="openCodeTab(event, 'UF-5', 'UF-5-CPP')">CPP</button></div><div id="UF-5-Python" class="code-tabcontent UF-5"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">connections</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">max_people</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">connections</span><span class="err"></span><span class="n">b</span>
    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">max_people</span><span class="p">)</span><span class="err"></span><span class="n">b</span>
    <span class="n">cur_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">count_increase</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">cur_counter</span>
        <span class="n">cur_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">cur_counter</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># The defaultdict now assigns a new id to every new person mentioned.
</span>    <span class="n">person_map</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">count_increase</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">connections</span><span class="p">):</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>
        <span class="n">uf</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">person_map</span><span class="p">[</span><span class="n">p1</span><span class="p">],</span> <span class="n">person_map</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span><span class="err"></span><span class="n">b</span>
        <span class="k">print</span><span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">person_map</span><span class="p">[</span><span class="n">p1</span><span class="p">]))</span><span class="err"></span><span class="n">b</span>
</pre></table></code></div></div></div><div id="UF-5-CPP" class="code-tabcontent UF-5"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">tests</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">connections</span><span class="p">;</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tests</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t_no</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">t_no</span><span class="o">&lt;</span><span class="n">tests</span><span class="p">;</span> <span class="n">t_no</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">connections</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">max_people</span> <span class="o">=</span> <span class="n">connections</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span><span class="err"></span><span class="n">b</span>
        <span class="n">UnionFind</span> <span class="n">uf</span><span class="p">(</span><span class="n">max_people</span><span class="p">);</span><span class="err"></span><span class="n">b</span>
        <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">person_map</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">connections</span><span class="p">;</span> <span class="n">c</span><span class="o">++&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">string</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">c1</span> <span class="o">&gt;&gt;</span> <span class="n">c2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">person_map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">person_map</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">person_map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">person_map</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">person_map</span><span class="p">[</span><span class="n">c1</span><span class="p">],</span> <span class="n">person_map</span><span class="p">[</span><span class="n">c2</span><span class="p">]);</span><span class="err"></span><span class="n">b</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">person_map</span><span class="p">[</span><span class="n">c1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="err"></span><span class="n">b</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></div></div></div><h1 id="a-slightly-hidden-application">A slightly hidden application</h1><p>Next, lets try a harder problem - <a href="https://www.spoj.com/problems/NITTROAD/">Roads of NITT</a>.</p><p>Have a go!</p><p>(Note: The input format is very weird (There’s some whitespace where there shouldn’t be). My current python solution fails for this reason)</p><div class="unlock"><p><button class="button_unlock hint">Hint</button></p><div class="show"><p><strong>Hint</strong></p><p>This problem seems similar but different to the problem above. We are still asking about connectivity, but we are breaking connections rather than forming them :(.</p><p>Consider this though - Would you be able to solve the problem if it was told in reverse?</p></div></div><div class="unlock"><p><button class="button_unlock solution">Solution</button></p><div class="show"><p><strong>Solution</strong></p><p>Looking at the problem in reverse, it seems we start off with a disconnected area, and then bit by bit, more connections are made. This is starting to look like Union Find!</p><p>So all we need to do is:</p><ol><li>Calculate what roads remain at the end of the problem<li>Answer the queries in reverse, joining instead of destroying<li>Reverse these results and print them</ol><p>However, we need to be a bit careful about what our results are in the first place - We want to count how many pairs of hostels are disconnected - This is an N^2 operation. We can do this in N using union find (For every vertex, we know how many vertices it is connected to (and therefore not connected to)), but we still don’t want to do this for every query. Let’s start by calculating the correct value after all roads have been destroyed.</p><p>If a road is formed, how many old pairs of hostels are no longer disconnected? A hostel can only be connected now and disconnected before if one of the hostels was already connected to the LHS of the road, and the other hostel was already connected to the RHS of the road. The number of possible pairs here is the size of the component on the LHS of the road, times the size of the component on the RHS of the road.</p><p>So every time we see an <code class="language-plaintext highlighter-rouge">R</code> query, we just need to update our current count of disconnect pairs using the Union Find:</p><div class="code-tab"> <button class="code-tablinks UF-6-link" onclick="openCodeTab(event, 'UF-6', 'UF-6-Python')">Python</button> <button class="code-tablinks UF-6-link" onclick="openCodeTab(event, 'UF-6', 'UF-6-CPP')">CPP</button></div><div id="UF-6-Python" class="code-tabcontent UF-6"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
        <span class="c1"># 0-index
</span>        <span class="n">edges</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">connected</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">queries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">queries</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">queries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">startswith</span><span class="p">(</span><span class="s">"R"</span><span class="p">):</span>
            <span class="n">connected</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="err"></span><span class="n">b</span>
    <span class="c1"># Add all remaining roadsb
</span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span><span class="err"></span><span class="n">b</span>
        <span class="k">if</span> <span class="n">connected</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span><span class="err"></span><span class="n">b</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="err"></span><span class="n">b</span>
    <span class="c1"># First - calculate how many pairs of hostels are disconnected.
</span>    <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="err"></span><span class="n">b</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span><span class="err"></span><span class="n">b</span>
        <span class="n">current</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="err"></span><span class="n">b</span>
    <span class="n">current</span> <span class="o">//=</span> <span class="mi">2</span><span class="err"></span><span class="n">b</span>
    <span class="c1"># Answering time!
</span>    <span class="n">queries</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">answers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">"Q"</span><span class="p">):</span>
            <span class="n">answers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">current</span> <span class="o">-=</span> <span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_index</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_index</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="err"></span><span class="n">b</span>
            <span class="n">uf</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_index</span><span class="p">])</span><span class="err"></span><span class="n">b</span>
    <span class="n">answers</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">answers</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># Separate ouput by a space
</span>    <span class="k">print</span><span class="p">()</span>
</pre></table></code></div></div></div><div id="UF-6-CPP" class="code-tabcontent UF-6"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">connected</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queries</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">answers</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">tests</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tests</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">tests</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">connected</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">queries</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">answers</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
            <span class="c1">// 0-index</span>
            <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">});</span>
        <span class="p">}</span>
        <span class="n">connected</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">q</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">q</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="s">"Q"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">queries</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
                <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
                <span class="n">queries</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">connected</span><span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">UnionFind</span> <span class="n">uf</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="c1">// Add all remaining roads</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">b</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">connected</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span><span class="err"></span><span class="n">b</span>
                <span class="n">uf</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span><span class="err"></span><span class="n">b</span>
            <span class="p">}</span><span class="err"></span><span class="n">b</span>
        <span class="p">}</span><span class="err"></span><span class="n">b</span>
        <span class="c1">// First - calculate how many pairs of hostels are disconnected.</span>
        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err"></span><span class="n">b</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="err"></span><span class="n">b</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="err"></span><span class="n">b</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="err"></span><span class="n">b</span>
        <span class="c1">// Answering Time!</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">queries</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">queries</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">qn</span><span class="o">:</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">qn</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">answers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">qn</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="o">*</span> <span class="n">uf</span><span class="p">.</span><span class="n">size_component</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">qn</span><span class="p">].</span><span class="n">second</span><span class="p">);</span><span class="err"></span><span class="n">b</span>
                <span class="n">uf</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">qn</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">qn</span><span class="p">].</span><span class="n">second</span><span class="p">);</span><span class="err"></span><span class="n">b</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">answers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">answers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">a</span><span class="o">:</span> <span class="n">answers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></div></div></div></div><div class="problems"><h1>Related Problems</h1><ul><li><a href="https://codeforces.com/problemset/problem/691/D" target="_blank">Swaps in Permutation</a><li><a href="https://codeforces.com/contest/805/problem/C" target="_blank">Find Amir</a><li><a href="https://codeforces.com/contest/915/problem/F" target="_blank">Imbalance Value of a Tree</a><li><a href="https://www.spoj.com/problems/CONSEC/" target="_blank">Consecutive Letters</a><li><a href="https://codeforces.com/contest/110/problem/E" target="_blank">Lucky Tree</a><li><a href="https://codeforces.com/contest/141/problem/E" target="_blank">Clearing Up</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/new_binder/categories/data-structures/'>Data Structures</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/new_binder/tags/difficulty-2/" class="post-tag no-text-decoration" >Difficulty 2</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL V3</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/new_binder/posts/uf/">Union Find / DSU</a><li><a href="/new_binder/posts/dp/">Dynamic Programming</a><li><a href="/new_binder/posts/lca/">Least Common Ancestor (LCA)</a><li><a href="/new_binder/posts/factorization/">Primes and Factorization Techniques</a><li><a href="/new_binder/posts/mod/">Modular Arithmetic</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/new_binder/tags/difficulty-3/">Difficulty 3</a> <a class="post-tag" href="/new_binder/tags/difficulty-2/">Difficulty 2</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/new_binder/posts/dp/"><div class="card-body"> <span class="timeago small" > Mar 26, 2021 <i class="unloaded">2021-03-26T10:32:00+11:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Dynamic Programming</h3><div class="text-muted small"><p> Why? Dynamic Programming (DP) is one of the most powerful tools you’ll come across in competitive programming. It normally turns up in about a third of all problems in a contest, in some form or a...</p></div></div></a></div><div class="card"> <a href="/new_binder/posts/lca/"><div class="card-body"> <span class="timeago small" > Apr 20, 2021 <i class="unloaded">2021-04-20T22:00:00+10:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Least Common Ancestor (LCA)</h3><div class="text-muted small"><p> Where is this useful? The Least Common Ancestor (LCA) data structure is useful wherever you have a directed graph where every vertex has out-degree \(\leq 1\). In more common terms, each vertex ha...</p></div></div></a></div><div class="card"> <a href="/new_binder/posts/problems-21-s2-c1/"><div class="card-body"> <span class="timeago small" > Aug 23, 2021 <i class="unloaded">2021-08-23T11:00:00+10:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Challenge Problems - 2021 Sem 2, Contest 1</h3><div class="text-muted small"><p> Sports Loans Statement Andrew is head of the sports club, and manages the inventory. Part of Andrew’s job is loaning footballs to people, and collecting those footballs once they have been used. ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/new_binder/posts/problems-21-s2-c1/" class="btn btn-outline-primary" prompt="Older"><p>Challenge Problems - 2021 Sem 2, Contest 1</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Loading comments from <a href="https://disqus.com/">Disqus</a> ...</p></div><script src="/new_binder/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//mcpc-1.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Union Find / DSU'; this.page.url = 'https://blog.monashicpc.com/new_binder//new_binder/posts/uf/'; this.page.identifier = '/posts/uf/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://discord.link/MonashICPC">Monash Programming Team</a>. <span data-toggle="tooltip" data-placement="top" title="Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/new_binder/tags/difficulty-3/">Difficulty 3</a> <a class="post-tag" href="/new_binder/tags/difficulty-2/">Difficulty 2</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/new_binder/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://blog.monashicpc.com/new_binder/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
