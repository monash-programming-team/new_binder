<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Least Common Ancestor (LCA)" /><meta name="author" content="Jackson Goerner" /><meta property="og:locale" content="en_US" /><meta name="description" content="Where is this useful?" /><meta property="og:description" content="Where is this useful?" /><link rel="canonical" href="https://blog.monashicpc.com/new_binder//new_binder/posts/lca/" /><meta property="og:url" content="https://blog.monashicpc.com/new_binder//new_binder/posts/lca/" /><meta property="og:site_name" content="Monash Code Binder" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-20T22:00:00+10:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Least Common Ancestor (LCA)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Jackson Goerner" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Jackson Goerner"},"description":"Where is this useful?","headline":"Least Common Ancestor (LCA)","dateModified":"2021-12-13T11:01:10+11:00","url":"https://blog.monashicpc.com/new_binder//new_binder/posts/lca/","datePublished":"2021-04-20T22:00:00+10:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.monashicpc.com/new_binder//new_binder/posts/lca/"},"@context":"https://schema.org"}</script><title>Least Common Ancestor (LCA) | Monash Code Binder</title><link rel="shortcut icon" href="/new_binder/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/new_binder/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="manifest" href="/new_binder/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/new_binder/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/new_binder/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/new_binder/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/new_binder/assets/js/dist/post.min.js"></script> <script> // see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> MathJax = { tex: { inlineMath: [ // start/end delimiter pairs for in-line math ['$','$'], ['\\(','\\)'] ], displayMath: [ // start/end delimiter pairs for display math ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="/new_binder/assets/js/code-tabs.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@5.2/distr/fira_code.css"> <script src="/new_binder/assets/js/hints.js"></script> <script src="/new_binder/assets/js/highlight.js"></script> <script defer src="/new_binder/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/new_binder/" alt="avatar" class="mx-auto"> <img src="/new_binder/assets/img/icpc.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/new_binder/">Monash Code Binder</a></div><div class="site-subtitle font-italic">For Training / Contests</div></div><ul class="w-100"><li class="nav-item"> <a href="/new_binder/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/new_binder/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/new_binder/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/new_binder/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/new_binder/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://discord.link/MonashICPC" aria-label="discord" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-discord"></i> </a> <a href="https://www.facebook.com/groups/454114112027992" aria-label="facebook" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-facebook"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['jackson','monashicpc.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/new_binder/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/new_binder/"> Posts </a> </span> <span>Least Common Ancestor (LCA)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Least Common Ancestor (LCA)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Jackson Goerner </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Apr 20, 2021, 10:00 PM +1000" > Apr 20, 2021 <i class="unloaded">2021-04-20T22:00:00+10:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Dec 13, 2021, 11:01 AM +1100" > Dec 13, 2021 <i class="unloaded">2021-12-13T11:01:10+11:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4037 words">22 min</span></div></div><div class="post-content"><h1 id="where-is-this-useful">Where is this useful?</h1><p>The Least Common Ancestor (LCA) data structure is useful wherever you have a directed graph where every vertex has out-degree \(\leq 1\). In more common terms, each vertex has a unique determined ‘parent’, or it is a root node, with no parent. The most common (and almost always only) example being a rooted tree.</p><p>On these particular graphs, the LCA gives us a fast way to move ‘up’ the graph (Towards your parents). In particular, we can use this to find the least common ancestor in \(\log (N)\) time, where the data structure gets its name from.</p><p>Reusing the analogy of parenting vertices, a vertex \(u\) is an ancestor of \(v\) if \(u\) is \(v\)’s parent, or \(v\)’s parent’s parent, and so on. As long as there is a line of ‘parentage’ connecting \(v\) to \(u\), \(u\) is an ancestor of \(v\). We consider \(v\) to also be it’s own ancestor.</p><p>The least common ancestor problem then requires, given two vertices \(x\) and \(y\), to find a vertex \(z\) in the graph such that \(z\) is an ancestor of both \(x\) and \(y\), but there is no vertex \(z’ \neq z\) such that \(z\) is an ancestor of \(z’\) and \(z’\) is an ancestor of \(x\) and \(y\) (In the tree example, we just want to find the lowest depth vertex whose subtree contains boths \(x\) and \(y\)).</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/new_binder/assets/img/posts/lca/graph-2.png" alt="" /></p><p>Note that the least common ancestor can be \(x\) or \(y\), if \(x\) is an ancestor of \(y\) or vice-versa.</p><h1 id="implementing-the-data-structure">Implementing the Data Structure</h1><h2 id="interface">Interface</h2><p>Let’s start by defining an interface for this data structure, and then slowly implement our methods.</p><div class="code-tab"> <button class="code-tablinks LCA-1-link" onclick="openCodeTab(event, 'LCA-1', 'LCA-1-Python')">Python</button> <button class="code-tablinks LCA-1-link" onclick="openCodeTab(event, 'LCA-1', 'LCA-1-CPP')">CPP</button></div><div id="LCA-1-Python" class="code-tabcontent LCA-1"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">LCA</span><span class="p">:</span>
<span class="s">"""
vertices are represented as numbers 0-&gt;n-1.
"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n_vertices</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># Once edges are added, build the tree/data structure.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># What is the lowest common ancestor of u, v?
</span>        <span class="c1"># Extension: Make this query from any root vertex you want.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span>
    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Find the distance between two vertices - very simple if we have LCA.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span></pre></table></code></div></div></div><div id="LCA-1-CPP" class="code-tabcontent LCA-1"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">LCA</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">adjacent</span><span class="p">;</span>

    <span class="n">LCA</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_vertices</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">),</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Once edges are added, build the tree/data structure.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// What is the lowest common ancestor of u, v?</span>
        <span class="c1">// Extension: Make this query from any root vertex you want.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Find the distance between two vertices - very simple if we have LCA.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><h2 id="useful-data">Useful data</h2><p>First off, let’s save some intermediary data that will make our life a lot easier, and strictly define the tree structure. We’ll introduce three arrays: <code class="language-plaintext highlighter-rouge">parent</code>, <code class="language-plaintext highlighter-rouge">level</code> and <code class="language-plaintext highlighter-rouge">length</code>.</p><ul><li><code class="language-plaintext highlighter-rouge">parent</code> stores the direct parent of any vertex in the rooted tree.<li><code class="language-plaintext highlighter-rouge">level</code> stores the level of the tree the vertex is at (Number of edges from it to the root)<li><code class="language-plaintext highlighter-rouge">length</code> stores the length of the vertex to the root (Using edge weights).</ul><p>We’ll populate these fields in the <code class="language-plaintext highlighter-rouge">build</code> method, since all edges should be added by then.</p><div class="code-tab"> <button class="code-tablinks LCA-2-link" onclick="openCodeTab(event, 'LCA-2', 'LCA-2-Python')">Python</button> <button class="code-tablinks LCA-2-link" onclick="openCodeTab(event, 'LCA-2', 'LCA-2-CPP')">CPP</button></div><div id="LCA-2-Python" class="code-tabcontent LCA-2"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">LCA</span><span class="p">:</span>
<span class="s">"""
vertices are represented as numbers 0-&gt;n-1.
"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n_vertices</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_parent</span><span class="p">,</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">c_length</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># Search from the source down the tree and set parent, level, length accordingly.n
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span><span class="err"></span><span class="n">n</span>
        <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span><span class="err"></span><span class="n">n</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">:</span><span class="err"></span><span class="n">n</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span> <span class="o">+</span> <span class="n">weight</span><span class="p">)</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># Once edges are added, build the tree/data structure.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="err"></span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># What is the lowest common ancestor of u, v?
</span>        <span class="c1"># Extension: Make this query from any root vertex you want.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span>
    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Find the distance between two vertices - very simple if we have LCA.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span></pre></table></code></div></div></div><div id="LCA-2-CPP" class="code-tabcontent LCA-2"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">LCA</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">adjacent</span><span class="p">;</span>
    <span class="n">vi</span> <span class="n">parent</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">length</span><span class="p">;</span><span class="err"></span><span class="n">n</span>

    <span class="n">LCA</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_vertices</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">),</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">level</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span><span class="err"></span><span class="n">m</span>

    <span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">T</span> <span class="n">c_length</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// Search from the source down the tree and set parent, level, length accordingly.n</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">])</span><span class="err"></span><span class="n">n</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span><span class="o">+</span><span class="n">v</span><span class="p">.</span><span class="n">second</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Once edges are added, build the tree/data structure.</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// What is the lowest common ancestor of u, v?</span>
        <span class="c1">// Extension: Make this query from any root vertex you want.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Find the distance between two vertices - very simple if we have LCA.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><p>So now we can query many useful characteristics of vertices in rooted trees. Now for the interesting part: let’s start creating data unique to the LCA structure.</p><h2 id="ancestor-array">Ancestor Array</h2><p>LCA gets its fast queries by precomputing a special array, called <code class="language-plaintext highlighter-rouge">ancestor</code>. Ancestor is a 2 dimensional array with <code class="language-plaintext highlighter-rouge">ancestor[v][k]</code> storing the ancestor of vertex <code class="language-plaintext highlighter-rouge">v</code> \(2^k\) edges towards the root. As an example, <code class="language-plaintext highlighter-rouge">ancestor[v][0]</code> is <code class="language-plaintext highlighter-rouge">parent[v]</code> (Parent is just ancestor 1 edge towards the root), and <code class="language-plaintext highlighter-rouge">ancestor[v][1]</code> is <code class="language-plaintext highlighter-rouge">parent[parent[v]]</code> where appropriate (2 edges towards root is same as parent’s parent).</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/new_binder/assets/img/posts/lca/graph-0.png" alt="" /></p><p>If you just populated this array by searching up the tree \(2^k\) steps each time, you’d have worst case complexity \(O(n^2)\) to build the array. Luckily, we can use the fact that <code class="language-plaintext highlighter-rouge">ancestor[v][k] = ancestor[ancestor[v][k-1]][k-1]</code> (In other words, you can move \(2^k\) steps towards the root by first moving \(2^{k-1}\) steps, which we’ve already computed, and then another \(2^{k-1}\) steps from this new position). This reduces the complexity to \(O(n\log_2(n))\)</p><p>We do this so that we can find the ancestor \(m\) edges towards the root for any arbitrary \(m\) in \(\log_2(m)\) time, while only using \(\log_2(n)\) space. We’ll see how this gets done later.</p><div class="code-tab"> <button class="code-tablinks LCA-3-link" onclick="openCodeTab(event, 'LCA-3', 'LCA-3-Python')">Python</button> <button class="code-tablinks LCA-3-link" onclick="openCodeTab(event, 'LCA-3', 'LCA-3-CPP')">CPP</button></div><div id="LCA-3-Python" class="code-tabcontent LCA-3"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">LCA</span><span class="p">:</span>
<span class="s">"""
vertices are represented as numbers 0-&gt;n-1.
"""</span>

    <span class="c1"># number such that 2^{MAX_LOG} &gt; n. 20 works for n &lt;= 10^6.n
</span>    <span class="n">MAX_LOG</span> <span class="o">=</span> <span class="mi">20</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n_vertices</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_parent</span><span class="p">,</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">c_length</span><span class="p">):</span>
        <span class="c1"># Search from the source down the tree and set parent, level, length accordingly.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span>
        <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span> <span class="o">+</span> <span class="n">weight</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># Once edges are added, build the tree/data structure.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Compute ancestorn
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># Initial step: ancestor[v][0] = parent[v]n
</span>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># Now, compute ancestor[v][k] from 1-&gt;MAX_LOGn
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="err"></span><span class="n">n</span>
                    <span class="c1"># Move 2^{k-1} up, then 2^{k-1} again.n
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># What is the lowest common ancestor of u, v?
</span>        <span class="c1"># Extension: Make this query from any root vertex you want.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span>
    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Find the distance between two vertices - very simple if we have LCA.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span></pre></table></code></div></div></div><div id="LCA-3-CPP" class="code-tabcontent LCA-3"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">LCA</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="c1">// number such that 2^{MAX_LOG} &gt; n. 20 works for n &lt;= 10^6.n</span>
    <span class="kt">int</span> <span class="n">MAX_LOG</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">adjacent</span><span class="p">;</span>
    <span class="n">vi</span> <span class="n">parent</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>
    <span class="n">vvi</span> <span class="n">ancestor</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">length</span><span class="p">;</span>

    <span class="n">LCA</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_vertices</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">),</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">level</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">T</span> <span class="n">c_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Search from the source down the tree and set parent, level, length accordingly.</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span><span class="p">;</span>
        <span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span><span class="p">;</span>
        <span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span><span class="o">+</span><span class="n">v</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Once edges are added, build the tree/data structure.</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="c1">// Compute ancestorn</span>
        <span class="n">ancestor</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vi</span><span class="p">(</span><span class="n">MAX_LOG</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// Initial step: ancestor[v][0] = parent[v]n</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
            <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// Now, compute ancestor[v][k] from 1-&gt;MAX_LOGn</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">MAX_LOG</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">n</span>
                    <span class="c1">// Move 2^{k-1} up, then 2^{k-1} again.n</span>
                    <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span><span class="err"></span><span class="n">n</span>
                <span class="p">}</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// What is the lowest common ancestor of u, v?</span>
        <span class="c1">// Extension: Make this query from any root vertex you want.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Find the distance between two vertices - very simple if we have LCA.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><h2 id="query">Query</h2><p>That’s actually most of the ingenuity out of the way, now we can get to implementing <code class="language-plaintext highlighter-rouge">query</code>.</p><p>Provided we want the LCA with respect to the root we called <code class="language-plaintext highlighter-rouge">build</code> from, we can define the LCA <code class="language-plaintext highlighter-rouge">l</code> of <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> in the following way:</p><p><code class="language-plaintext highlighter-rouge">l</code> is the ancestor of <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> maximising <code class="language-plaintext highlighter-rouge">level[l]</code>.</p><p>We also know that <code class="language-plaintext highlighter-rouge">level[l] &lt;= min(level[u], level[v])</code>. Using this, we can calculate <code class="language-plaintext highlighter-rouge">query(u, v)</code> by:</p><ul><li>Finding the ancestors of <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> (call them <code class="language-plaintext highlighter-rouge">a1</code>, <code class="language-plaintext highlighter-rouge">a2</code>) such that <code class="language-plaintext highlighter-rouge">level[a1] = level[a2] = min(level[u], level[v])</code>.<li>Keep moving <code class="language-plaintext highlighter-rouge">a1</code> and <code class="language-plaintext highlighter-rouge">a2</code> towards the root (higher and higher ancestors) until <code class="language-plaintext highlighter-rouge">a1 == a2</code>. Then <code class="language-plaintext highlighter-rouge">a1</code> and <code class="language-plaintext highlighter-rouge">a2</code> are the LCA of <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code>.</ul><p>We can do both of these things on \(\log_2(n)\) time with this <code class="language-plaintext highlighter-rouge">ancestor</code> array we’ve generated. Let’s see how:</p><div class="code-tab"> <button class="code-tablinks LCA-4-link" onclick="openCodeTab(event, 'LCA-4', 'LCA-4-Python')">Python</button> <button class="code-tablinks LCA-4-link" onclick="openCodeTab(event, 'LCA-4', 'LCA-4-CPP')">CPP</button></div><div id="LCA-4-Python" class="code-tabcontent LCA-4"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">LCA</span><span class="p">:</span>
<span class="s">"""
vertices are represented as numbers 0-&gt;n-1.
"""</span>

    <span class="c1"># number such that 2^{MAX_LOG} &gt; n. 20 works for n &lt;= 10^6.
</span>    <span class="n">MAX_LOG</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n_vertices</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_parent</span><span class="p">,</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">c_length</span><span class="p">):</span>
        <span class="c1"># Search from the source down the tree and set parent, level, length accordingly.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span>
        <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span> <span class="o">+</span> <span class="n">weight</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># Once edges are added, build the tree/data structure.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span>
        <span class="c1"># Initial step: ancestor[v][0] = parent[v]
</span>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="c1"># Now, compute ancestor[v][k] from 1-&gt;MAX_LOG
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Move 2^{k-1} up, then 2^{k-1} again.
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># What is the lowest common ancestor of u, v?
</span>        <span class="c1"># Extension: Make this query from any root vertex you want.
</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span><span class="err"></span><span class="n">n</span>
            <span class="k">pass</span> <span class="c1"># TODOn
</span>        <span class="c1"># assume that u is higher up than v, to simplify the code belown
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span><span class="err"></span><span class="n">n</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># STEP 1: set u and v to be ancestors with the same leveln
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]):</span><span class="err"></span><span class="n">n</span>
                <span class="c1"># If v is 2^k levels below u, move it up 2^k levels.n
</span>                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># We can be certain that level[u] = level[v]. Reason: binary representation of all natural numbers.n
</span>        <span class="c1"># Do we need to move to step 2?n
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">):</span> <span class="k">return</span> <span class="n">u</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># STEP 2: find the highest ancestor where u != v. Then the parent is the LCAn
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="err"></span><span class="n">n</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]):</span><span class="err"></span><span class="n">n</span>
                <span class="c1"># Move up 2^k stepsn
</span>                <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="err"></span><span class="n">n</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="err"></span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Find the distance between two vertices - very simple if we have LCA.
</span>        <span class="k">pass</span> <span class="c1"># TODO
</span></pre></table></code></div></div></div><div id="LCA-4-CPP" class="code-tabcontent LCA-4"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">LCA</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="c1">// number such that 2^{MAX_LOG} &gt; n. 20 works for n &lt;= 10^6.</span>
    <span class="kt">int</span> <span class="n">MAX_LOG</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">adjacent</span><span class="p">;</span>
    <span class="n">vi</span> <span class="n">parent</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>
    <span class="n">vvi</span> <span class="n">ancestor</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">length</span><span class="p">;</span>

    <span class="n">LCA</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_vertices</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">),</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">level</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">T</span> <span class="n">c_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Search from the source down the tree and set parent, level, length accordingly.</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span><span class="p">;</span>
        <span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span><span class="p">;</span>
        <span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span><span class="o">+</span><span class="n">v</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Once edges are added, build the tree/data structure.</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="c1">// Compute ancestor</span>
        <span class="n">ancestor</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vi</span><span class="p">(</span><span class="n">MAX_LOG</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="c1">// Initial step: ancestor[v][0] = parent[v]</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
            <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="c1">// Now, compute ancestor[v][k] from 1-&gt;MAX_LOG</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">MAX_LOG</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Move 2^{k-1} up, then 2^{k-1} again.</span>
                    <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// What is the lowest common ancestor of u, v?</span>
        <span class="c1">// Extension: Make this query from any root vertex you want.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="err"></span><span class="n">n</span>
            <span class="c1">// TODOn</span>
        <span class="p">}</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// assume that u is higher up than v, to simplify the code belown</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// STEP 1: set u and v to be ancestors with the same leveln</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">MAX_LOG</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span><span class="err"></span><span class="n">n</span>
                <span class="c1">// If v is 2^k levels below u, move it up 2^k levels.n</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">];</span><span class="err"></span><span class="n">n</span>
            <span class="p">}</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// We can be certain that level[u] = level[v]. Reason: binary representation of all natural numbers.n</span>
        <span class="c1">// Do we need to move to step 2?n</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="err"></span><span class="n">n</span>
        <span class="c1">// STEP 2: find the highest ancestor where u != v. Then the parent is the LCAn</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">MAX_LOG</span><span class="p">;</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span><span class="err"></span><span class="n">n</span>
                <span class="c1">// Move up 2^k stepsn</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">];</span><span class="err"></span><span class="n">n</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">];</span><span class="err"></span><span class="n">n</span>
            <span class="p">}</span><span class="err"></span><span class="n">n</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Find the distance between two vertices - very simple if we have LCA.</span>
        <span class="c1">// TODO</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><p>Nice! That’s the main functionality of LCA completed.</p><h2 id="corrolaries">Corrolaries</h2><p>Let’s quickly tackle the two remaining implementations:</p><ul><li>Calculating the distance between two vertices <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code> is the same as calculating the distance between <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">query(u, v)</code>, and adding that to the distance between <code class="language-plaintext highlighter-rouge">v</code> and <code class="language-plaintext highlighter-rouge">query(u, v)</code><li>Calculating the LCA from a particular root, just requires a slight change in perspective. For two vertices <code class="language-plaintext highlighter-rouge">u</code> and <code class="language-plaintext highlighter-rouge">v</code>, and custom root <code class="language-plaintext highlighter-rouge">r</code>, the LCA will always be one of <code class="language-plaintext highlighter-rouge">query(u, v)</code>, <code class="language-plaintext highlighter-rouge">query(u, r)</code> or <code class="language-plaintext highlighter-rouge">query(v, r)</code>.</ul><div class="code-tab"> <button class="code-tablinks LCA-5-link" onclick="openCodeTab(event, 'LCA-5', 'LCA-5-Python')">Python</button> <button class="code-tablinks LCA-5-link" onclick="openCodeTab(event, 'LCA-5', 'LCA-5-CPP')">CPP</button></div><div id="LCA-5-Python" class="code-tabcontent LCA-5"><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">LCA</span><span class="p">:</span>
<span class="s">"""
vertices are represented as numbers 0-&gt;n-1.
"""</span>

    <span class="c1"># number such that 2^{MAX_LOG} &gt; n. 20 works for n &lt;= 10^6.
</span>    <span class="n">MAX_LOG</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n_vertices</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_parent</span><span class="p">,</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">c_length</span><span class="p">):</span>
        <span class="c1"># Search from the source down the tree and set parent, level, length accordingly.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span>
        <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span> <span class="o">+</span> <span class="n">weight</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># Once edges are added, build the tree/data structure.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">)]</span>
        <span class="c1"># Initial step: ancestor[v][0] = parent[v]
</span>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="c1"># Now, compute ancestor[v][k] from 1-&gt;MAX_LOG
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Move 2^{k-1} up, then 2^{k-1} again.
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># What is the lowest common ancestor of u, v?
</span>        <span class="c1"># Extension: Make this query from any root vertex you want.
</span>        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Custom root -- see diagrams below for reasoning.n
</span>            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span><span class="err"></span><span class="n">n</span>
            <span class="c1"># Case 1: root is in the same component as u when `a` is removed from the tree. So `b` is the LCAn
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">b</span><span class="err"></span><span class="n">n</span>
            <span class="c1"># Case 2: root is in the same component as v when `a` is removed from the tree. So `a` is the LCAn
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">c</span><span class="err"></span><span class="n">n</span>
            <span class="c1"># Case 3: b and c are above a in the tree. So return an
</span>            <span class="k">return</span> <span class="n">a</span><span class="err"></span><span class="n">n</span>
        <span class="c1"># assume that u is higher up than v, to simplify the code below
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span>
        <span class="c1"># STEP 1: set u and v to be ancestors with the same level
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]):</span>
                <span class="c1"># If v is 2^k levels below u, move it up 2^k levels.
</span>                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="c1"># We can be certain that level[u] = level[v]. Reason: binary representation of all natural numbers.
</span>        <span class="c1"># Do we need to move to step 2?
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">):</span> <span class="k">return</span> <span class="n">u</span>
        <span class="c1"># STEP 2: find the highest ancestor where u != v. Then the parent is the LCA
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">MAX_LOG</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]):</span>
                <span class="c1"># Move up 2^k steps
</span>                <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Find the distance between two vertices
</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span><span class="err"></span><span class="n">n</span>
</pre></table></code></div></div></div><div id="LCA-5-CPP" class="code-tabcontent LCA-5"><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">LCA</span> <span class="p">{</span>
    <span class="c1">// vertices are represented as numbers 0-&gt;n-1.</span>
    <span class="c1">// number such that 2^{MAX_LOG} &gt; n. 20 works for n &lt;= 10^6.</span>
    <span class="kt">int</span> <span class="n">MAX_LOG</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">adjacent</span><span class="p">;</span>
    <span class="n">vi</span> <span class="n">parent</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>
    <span class="n">vvi</span> <span class="n">ancestor</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">length</span><span class="p">;</span>

    <span class="n">LCA</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_vertices</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">),</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">level</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
        <span class="n">adjacent</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_level</span><span class="p">,</span> <span class="n">T</span> <span class="n">c_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Search from the source down the tree and set parent, level, length accordingly.</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_parent</span><span class="p">;</span>
        <span class="n">level</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_level</span><span class="p">;</span>
        <span class="n">length</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_length</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">adjacent</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">c_parent</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c_level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_length</span><span class="o">+</span><span class="n">v</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Once edges are added, build the tree/data structure.</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="c1">// Compute ancestor</span>
        <span class="n">ancestor</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vi</span><span class="p">(</span><span class="n">MAX_LOG</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="c1">// Initial step: ancestor[v][0] = parent[v]</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
            <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="c1">// Now, compute ancestor[v][k] from 1-&gt;MAX_LOG</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">MAX_LOG</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Move 2^{k-1} up, then 2^{k-1} again.</span>
                    <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// What is the lowest common ancestor of u, v?</span>
        <span class="c1">// Extension: Make this query from any root vertex you want.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Custom root -- see diagrams below for reasoning.n</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span><span class="err"></span><span class="n">n</span>
            <span class="c1">// Case 1: root is in the same component as u when `a` is removed from the tree. So `b` is the LCAn</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">c</span> <span class="n">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">b</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
            <span class="c1">// Case 2: root is in the same component as v when `a` is removed from the tree. So `a` is the LCAn</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="n">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
            <span class="c1">// Case 3: b and c are above a in the tree. So return an</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">;</span><span class="err"></span><span class="n">n</span>
        <span class="p">}</span>
        <span class="c1">// assume that u is higher up than v, to simplify the code below</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="c1">// STEP 1: set u and v to be ancestors with the same level</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">MAX_LOG</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
                <span class="c1">// If v is 2^k levels below u, move it up 2^k levels.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="c1">// We can be certain that level[u] = level[v]. Reason: binary representation of all natural numbers.</span>
        <span class="c1">// Do we need to move to step 2?</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span>
        <span class="c1">// STEP 2: find the highest ancestor where u != v. Then the parent is the LCA</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">MAX_LOG</span><span class="p">;</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
                <span class="c1">// Move up 2^k steps</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Find the distance between two vertices</span>
        <span class="k">return</span> <span class="n">length</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">length</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">length</span><span class="p">[</span><span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)];</span><span class="err"></span><span class="n">n</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/new_binder/assets/img/posts/lca/graph-3.png" alt="" /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/new_binder/assets/img/posts/lca/graph-4.png" alt="" /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/new_binder/assets/img/posts/lca/graph-5.png" alt="" /></p><p>And that’s our implementation done! Now get out there and solve some problems!</p></div><div class="problems"><h1>Related Problems</h1><ul><li> <a data-toggle="tooltip" data-html="true" title="This problem cannot be linked to. If it is from NZPC or a Regional, you can probably find it on <a href='https://prog4fun.csse.canterbury.ac.nz/login/index.php' target='_blank'>this site</a>">coming soon</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/new_binder/categories/data-structures/'>Data Structures</a>, <a href='/new_binder/categories/trees/'>Trees</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/new_binder/tags/difficulty-3/" class="post-tag no-text-decoration" >Difficulty 3</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL V3</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/new_binder/posts/uf/">Union Find / DSU</a><li><a href="/new_binder/posts/dp/">Dynamic Programming</a><li><a href="/new_binder/posts/lca/">Least Common Ancestor (LCA)</a><li><a href="/new_binder/posts/factorization/">Primes and Factorization Techniques</a><li><a href="/new_binder/posts/mod/">Modular Arithmetic</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/new_binder/tags/difficulty-3/">Difficulty 3</a> <a class="post-tag" href="/new_binder/tags/difficulty-2/">Difficulty 2</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/new_binder/posts/mod/"><div class="card-body"> <span class="timeago small" > Mar 29, 2021 <i class="unloaded">2021-03-29T18:40:00+11:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Modular Arithmetic</h3><div class="text-muted small"><p> What is it? Modular Arithmetic encompasses all sorts of theorems and optimizations surrounding the % operator in C and Python. As you’ll see in the related problems, modulo arithmetic is often ti...</p></div></div></a></div><div class="card"> <a href="/new_binder/posts/factorization/"><div class="card-body"> <span class="timeago small" > Apr 5, 2021 <i class="unloaded">2021-04-05T11:00:00+10:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Primes and Factorization Techniques</h3><div class="text-muted small"><p> Why? Many number theoretic problems in competitive programming require analysing the factors or prime factors of a number. Here I’ll list a few techniques for finding these factors, and some techn...</p></div></div></a></div><div class="card"> <a href="/new_binder/posts/dp/"><div class="card-body"> <span class="timeago small" > Mar 26, 2021 <i class="unloaded">2021-03-26T10:32:00+11:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Dynamic Programming</h3><div class="text-muted small"><p> Why? Dynamic Programming (DP) is one of the most powerful tools you’ll come across in competitive programming. It normally turns up in about a third of all problems in a contest, in some form or a...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/new_binder/posts/factorization/" class="btn btn-outline-primary" prompt="Older"><p>Primes and Factorization Techniques</p></a> <a href="/new_binder/posts/problems-21-s2-c1/" class="btn btn-outline-primary" prompt="Newer"><p>Challenge Problems - 2021 Sem 2, Contest 1</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Loading comments from <a href="https://disqus.com/">Disqus</a> ...</p></div><script src="/new_binder/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//mcpc-1.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Least Common Ancestor (LCA)'; this.page.url = 'https://blog.monashicpc.com/new_binder//new_binder/posts/lca/'; this.page.identifier = '/posts/lca/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://discord.link/MonashICPC">Monash Programming Team</a>. <span data-toggle="tooltip" data-placement="top" title="Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/new_binder/tags/difficulty-3/">Difficulty 3</a> <a class="post-tag" href="/new_binder/tags/difficulty-2/">Difficulty 2</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/new_binder/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://blog.monashicpc.com/new_binder/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
